options
{
  STATIC = false; // para que pueda haber concurrencia (permite entradas de manera dinamica) 
  DEBUG_PARSER = true;
  // DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Parser)

package piat.javacc;

public class Parser {
  void skipto(int kind, Exception e){
      if(e!=null){
        System.out.println("\u001B[31m"+"Traza mal formada detectada..."+"\u001B[0m");
        eg.registrarError();
      }
		Token t; 
    	do {
        	t = getNextToken();
  		} while (t.kind != kind);
	}
}
PARSER_END(Parser)

<*>
SKIP :
{
  " "
| "\t"
| "\r"
| "bounced from:" : DEFAULT // este token se define ya que en los smtp-in hay este token seguido de un remitente y correo, por lo que cuando lo detectemos debemos salir de ese estado lexico y ir al por defecto
}

/** Los siguientes tokens tienen que ser especificados en todos los estados lexicos (*) ya que en la parte sintactica si ponemos un token a pelo (por ejemplo: "message from"), el parser lo detecta como un token definido el estado léxico DEFAULT, no un token definido en todo estado lexico. Es por ello que el no-terminal CualquierCosa se ponen los tokens definidos a continuación */
<*>
TOKEN:
{
  < NUMERO : (["0"-"9"])+ > 
| < LETRA : ["A"-"Z","a"-"z"] >
| < IDENTIFICADOR_TRAZA : "["(["A"-"Z","0"-"9"])+"]:" > // el id de traza tiene que estar aqui definido porque algunos servidores utilizan estados lexicos propios
| < PUNTO : "." > 
| < DOS_PUNTOS : ":" >
| < GUION : "-" >
| < GUION_BAJO : "_" >
| < ARROBA : "@" >
| < IGUAL : "=" >
| < ABRE_PARENTESIS : "(" >
| < CIERRA_PARENTESIS : ")" >
| < COMA : "," >
| < MENOR_QUE : "<" >
| < MAYOR_QUE : ">" >
| < OVERLOAD : "overload)" > // este token tiene que estar aqui definido ya que puede aparecer en cualquier tipo de servidor
| < BAD : "(bad destination mailbox address)" > // este token tiene que estar aqui definido ya que puede aparecer en cualquier tipo de servidor
| < EOL : "\n" > : DEFAULT // se encuentre en el estado lexico que se encuentre, cuando encuentre un EOL pasa a default
}

TOKEN : 
{
  < FECHA : (["0"-"9"]){4}"-"(["0"-"9"]){2}"-"(["0"-"9"]){2} >  
| < HORA : (["0"-"9"]){2}":"(["0"-"9"]){2}":"(["0"-"9"]){2} > : SERVER
}

/** El estado lexico server se ha definido principalmente por un motivo, y es debido a que en mucho ficheros de log se encuentra tipos de servidor (bounced from: <MAILER-DAEMON@smtp-in2.etsist.upm.es> ) por lo que es necesario definir un estado lexico en el que unicamente queramos detectar el tipo de servidor al que pertenece la traza. */
<SERVER>
TOKEN:
{
  < MSA : "msa" > : GEN
| < SMTP_IN : "smtp-in" > : GEN //: DEFAULT
| < SMTP_OUT : "smtp-out" > : OUT
| < SEC : ("security-in"|"security-out") > : SECURITY
| < USER_MAILBOX : "user-mailbox" > : DEFAULT
}

/** Este estado lexico se define ya que hace falta definir los token que queramos que se identifiquen en las trazas security-in/out */
<SECURITY>
TOKEN:
{
  < INFECTED : "INFECTED" > : DEFAULT
| < SEC_PASSED : "SEC-PASSED:" > : PASS
| < SECURITY_ANTIVIRUS : "security-antivirus:" >
}

<GEN>
TOKEN:
{
  < REMIT : "<"(["A"-"Z","a"-"z","0"-"9","_",".","-"])+ >
| < DOM : "@"(["A"-"Z","a"-"z","0"-"9","_"])+ ("."(["A"-"Z","a"-"z","0"-"9","_"])+)+">" >
| < FROM :  "message from:" >
}

<OUT>
TOKEN:
{
  <RELAY_TO : "relay to:" > 
}

/** Este estado se define ya que hay tanto para los mensajes SEC-BLOCKED (infectados) como SEC-PASSED (spam) existe el "token" security-antivirus. En el caso de mensajes infectados es imprescindible que aparezca "security-antivirus", mientras que los de SPAM no. Es por ello por lo que se ha creado un estado lexico para que "obvie" ese token y no haya conflictos a la hora de que el tokenmanager detecte el token. */
<PASS>
TOKEN:
{
  <SECURITY_ANTISPAM : "security-antispam:" >
| <SPAM : "SPAM" >
}

/** Producción principal. */
// Se pone (<EOL>)? ya que en algunos no-terminales una vez se ha detectado lo que interesa, consume todos los tokens de esa traza hasta llegar al final de línea, consumiendo tambien ese token. Es por eso que en esos casos puede no estar presente el <EOL>
void Start() : {}
{
  (Traza() (<EOL>)?)*
  <EOF>
}

/** Una Traza. */
void Traza() : {}
{
  Fecha() Hora() TipoTraza() 
}

/** Un tipo de traza. */
/** El LOOKAHEAD sirve para poder comprobar todas los tipos de trazas que se quieren analizar y ver de todas ellas cual es la que encaja. Concretamente, el LOOKAHEAD tiene como funcion mirar un numero n de tokens hacia delante, para poder determinar que no-terminal es el correcto.*/
void TipoTraza(String f) : {}
{
  LOOKAHEAD(TrazaGEN())   TrazaGEN() 
| LOOKAHEAD(TrazaIN())    TrazaIN()
| LOOKAHEAD(TrazaOUT())   TrazaOUT()    
| LOOKAHEAD(TrazaINF())   TrazaINF()    
| LOOKAHEAD(TrazaSPAM())  TrazaSPAM()   
| LOOKAHEAD(TrazaOVER())  TrazaOVER()   
| LOOKAHEAD(TrazaBAD())   TrazaBAD()    
| LOOKAHEAD(TrazaValida())TrazaValida() 
}

void TrazaGEN() : {}
{ 
  <MSA> Numero() Identificador() Intento() 
}

void TrazaIN() : {}
{ 
  <SMTP_IN> Numero() Identificador() Intento() 
}

void TrazaOUT() : {}
{ 
  <SMTP_OUT> Numero() Identificador() RelayTo() 
}

void TrazaSPAM() : {}
{ 
  <SEC> Numero() Identificador() SpamNoBloq() 
}

void TrazaINF() : {}
{ 
  <SEC> Numero() Identificador() Infectado() 
}

void TrazaOVER() : {}
{ 
  TipoServidor() Numero() Identificador() Sobrecarga() 
}

void TrazaBAD() : {}
{ 
  TipoServidor() Numero() Identificador() Nodest() 
}

void TrazaValida() : {}
{
  TipoServidor() Numero() Identificador() CualquierCosa() 
}

/* Otras producciones */

void TipoServidor() : {}
{ 
  ( t=<MSA> | t=<SMTP_IN> | t=<SMTP_OUT> | t=<SEC> | t=<USER_MAILBOX>) 
}

void Fecha() : {} 
{ 
  <FECHA> {}
}

void Hora() : {}
{ 
  <HORA> 
}

void Numero() : {}
{ 
  <NUMERO> 
}

void Identificador() : {}
{ 
  <IDENTIFICADOR_TRAZA> 
} 

void Intento() : {}
{
  <FROM> <REMIT> <DOM> {
    skipto(EOL,null);
  }
} 

void RelayTo() : {}
{
  <RELAY_TO> Relay(){
    skipto(EOL,null);
  }
}

void SpamNoBloq() : {}
{
  <SEC_PASSED> CualquierCosa() <SECURITY_ANTISPAM> <SPAM> 
}

void Infectado(Token t) : { Token u; }
{
  CualquierCosa() <SECURITY_ANTIVIRUS> <INFECTED> {
    skipto(EOL,null); 
  }
}

void Sobrecarga(Token t) : {} 
{
  CualquierCosa() <OVERLOAD> 
}

void Nodest(Token t) : {}
{
  CualquierCosa() <BAD>
}

/** Se define el no-terminal CualquierCosa y no un token que recoga cualquier cosa (~[]) , debido a que este ultimo no permitiría reconocer ningun otro token que quisiesemos, aunque estos tuviesen prioridad. Es mas conveniente definir un no-terminal con los cualquier token que puede haber hasta encontrar el token que queramos reconocer. */
void CualquierCosa() : {}
{
  ( <LETRA> | <NUMERO> | <GUION_BAJO> | <PUNTO> | <GUION> | <DOS_PUNTOS> | <MENOR_QUE> | <MAYOR_QUE> | <IGUAL> | <ABRE_PARENTESIS> | <CIERRA_PARENTESIS> | <COMA> | <ARROBA>)*
}

void Relay() : {}
{
  ( <LETRA>| <NUMERO> | "_" | "." | "-" )*
}