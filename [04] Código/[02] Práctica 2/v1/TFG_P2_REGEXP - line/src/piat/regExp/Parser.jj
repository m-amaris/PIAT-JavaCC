options
{
  STATIC = false;
  JAVA_TEMPLATE_TYPE = "modern";
  UNICODE_INPUT=true; // Permite reconocer caracteres Unicode sin que todo explote :) Especificar el encoding (UTF-8)
  // DEBUG_PARSER = true;
  // DEBUG_LOOKAHEAD = true;
  // DEBUG_TOKEN_MANAGER = true;
} 

PARSER_BEGIN(Parser)
package piat.javacc;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Map; 

public class Parser {}
PARSER_END(Parser)

SKIP :
{
  " "
| "\t" 
| "\n" 
| "\r"
}

TOKEN : 
{ 
  < FECHA : (["0"-"9"]){4}"-"(["0"-"9"]){2}"-"(["0"-"9"]){2} >  // [0-9]{4}-[0-9]{2}-[0-9]{2}  
| < HORA : (["0"-"9"]){2}":"(["0"-"9"]){2}":"(["0"-"9"]){2} > //  \s[0-9]{2}:[0-9]{2}:[0-9]{2}
//| < TIPO_SERVIDOR : " "(~["0"-"9"])+ > // \s[^0-9]+
| < TIPO_SERVIDOR : " "(["A"-"Z","a"-"z","-"])+ > 							
| < NUMERO_SERVIDOR : (["0"-"9"])+ >  // [0-9]+
| < MENSAJE :  " ""["(["a"-"z","A"-"Z","0"-"9","_"])+"]:"(~["\r","\n"])* >  // \s\[\w+\]:.*
}

void procesarLinea(AtomicInteger lineasCorrectas,ConcurrentHashMap<String, String> hmServidores,ConcurrentHashMap <String,AtomicInteger> hmUsuarios,ConcurrentHashMap<String, Pattern> hmPatronesEstadisticasAgregadas,ConcurrentHashMap<String, AtomicInteger> hmEstadisticasAgregadas) :
{
  Token fecha,hora,tipoServidor,numeroServidor;
  Token mensaje = null;
  String traza;
} 
{ 
    (
    fecha=<FECHA>
    hora=<HORA>
    tipoServidor=<TIPO_SERVIDOR>
    numeroServidor=<NUMERO_SERVIDOR>
    mensaje=<MENSAJE> 
     {
	  traza = fecha.image+hora.image+tipoServidor.image+numeroServidor.image+mensaje.image;
      // estadisticasServidor
      hmServidores.put(tipoServidor.image+numeroServidor.image, tipoServidor.image);
    	
      // estadisticasUsuarios
	  Matcher comparador = Pattern.compile(".*\\smsa.*message.*\\sfrom:\\s<([\\w-]+\\.[\\w-]+)@.*").matcher(traza);
	  if (comparador.matches()) {
	    final AtomicInteger contadorAnterior = hmUsuarios.putIfAbsent(comparador.group(1), new AtomicInteger(1));
	    if (contadorAnterior != null) contadorAnterior.incrementAndGet();
	    }


      // estadisticasAgregadas
		String clave, estadistico;
		final AtomicInteger contadorAnterior2;

		// Recorrer el mapa hmpatron2esEstadisticasAgregadas, que contiene los patron2es a
		// probar, para ver si cada uno de esos patron2es casan con la traza a analizar
		for (Map.Entry<String, Pattern> entrada : hmPatronesEstadisticasAgregadas.entrySet()) {
			estadistico = entrada.getKey(); // String con el nombre del estad�stico
			if (entrada.getValue().matcher(traza).matches()) { // Si casa, entonces actualizar el mapa hmEstadisticasAgregadas
				clave = tipoServidor + " " + " " + fecha + " " + estadistico; // La clave del mapa
																				// hmEstadisticasAgregadas est� formada
																				// por el tipo del servidor y el nombre
																				// del estad�stico
				// hmEstadisticasAgregadas
				// estara formada por el tipo del servidor, la fecha de la traza y el nombre del
				// estadistico.
				// Por ejemplo "security-in 2020-02-21 - msgBLOCKED"

				// A�adir el estad�stico al mapa. Si no existe el valor del contador es 1, pero
				// si existe, se recupera el valor y se incrementa
				contadorAnterior2 = hmEstadisticasAgregadas.putIfAbsent(clave, new AtomicInteger(1));
				if (contadorAnterior2 != null)
					contadorAnterior2.incrementAndGet();
				break; // Este break sale del for, pues al ser los patron2es disjuntos, en cuanto una
						// l�nea cumple un patr�n, no hace falta mirar otros patron2es
			}
		}
		lineasCorrectas.incrementAndGet();
	  // System.out.println(traza);
      }
    )*
  < EOF >
}
