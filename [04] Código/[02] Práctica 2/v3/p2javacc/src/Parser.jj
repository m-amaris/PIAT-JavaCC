options
{
  STATIC = false; // para que pueda haber concurrencia (permite entradas de manera dinamica) 
  // DEBUG_PARSER = true; 
  // DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Parser)

package piat.javacc;
import java.io.File; 
import java.util.StringTokenizer;

@SuppressWarnings("unused") // quitar warnings en Parser.java
public class Parser {
  private EstUsuario eu ;
  private EstGenerales eg ;
  private EstAgregadasTipoFecha ea ;
  private String f,t,n;
  private Token tkn;

  public Parser(ParserTokenManager parser, EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea){
    this(parser); 
    this.eu = eu;
    this.eg = eg;
    this.ea = ea;
  }

  void skipto(int kind, Exception e){
    if(e!=null){
      // System.out.println("[ERROR EN PARSER] Traza mal formada detectada..."+e.getMessage());
      eg.registrarError();
    } 
    while(getToken(1).kind != kind) // https://javacc.github.io/javacc/documentation/api.html#returning-tokens
      getNextToken(); 
	}

  private void Registar(String estadistico, String tipoServidor, String numeroServidor,String fecha){
    eg.registrarServidor(tipoServidor,numeroServidor);
		ea.registrarTraza(tipoServidor,fecha,estadistico);
  }

}

PARSER_END(Parser)



<*> SKIP : {
  " "
| "\t"
| "\r"
}

<*> TOKEN : {
  < EOL : "\n" > : DEFAULT
}

<DEFAULT> TOKEN : {
  < FECHA : (["0"-"9"]){4}"-"(["0"-"9"]){2}"-"(["0"-"9"]){2} >  
| < HORA : (["0"-"9"]){2}":"(["0"-"9"]){2}":"(["0"-"9"]){2} > : SERVER
| < NO_FECHA : ~["\n"] > // cualquier cosa que no sea una fecha
}

<SERVER> TOKEN : {
  < MSA : "msa" > : LEX_MSA
| < SMTP_IN : "smtp-in" > : LEX_IN 
| < SMTP_OUT : "smtp-out" > : LEX_OUT
| < SEC : ("security-in"|"security-out") > : LEX_SEC
| < ID_SERVIDOR :  ((<LETRA>)+("-")?(<LETRA>)+) > : VALIDA
}

<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC,VALIDA> TOKEN : {
  < NUMERO : ["0"-"9"] > 
| < IDENTIFICADOR_TRAZA : "["(["A"-"Z","0"-"9"])+"]:" >    // el id de traza tiene que estar aqui definido porque algunos servidores utilizan estados lexicos propios
}
 
<LEX_IN> TOKEN : {
  < BOUNCED : "bounced from:">  // este token se define ya que en los smtp-in hay este token seguido de un remitente y correo, por lo que cuando lo detectemos debemos salir de ese estado lexico y ir al por defecto
| < PERMA_REJECTED : "permanently rejected, dsn:" >
}

<LEX_SEC> TOKEN : {
  < INFECTED : "security-antivirus: INFECTED" >
| < SPAM : "security-antispam: SPAM" >
| < SEC_PASSED : "SEC-PASSED:" >
| < SEC_BLOCKED : "SEC-BLOCKED:" >
| < HAM : "security-antispam: HAM" >
}

<VALIDA> TOKEN : {
  < MENOR_QUE : "<" >
| < MAYOR_QUE : ">" >
| < ARROBA : "@" >
| < ABRE_PARENTESIS : "(" >
| < CIERRA_PARENTESIS : ")" >
| < GUION_BAJO : "_" >
}

<VALIDA,LEX_SEC> TOKEN : {
  < GUION : "-" >
}

<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC> TOKEN : {
  < MAIL : "<"(["A"-"Z","a"-"z","0"-"9","_",".","-"])+ "@"(["A"-"Z","a"-"z","0"-"9","_","-"])+ ("."(["A"-"Z","a"-"z","0"-"9","_"])+)+">" >
| < FROM :  "message from:" >
| < OVERLOAD : "(overload)" >
| < ACCEPTED : "(accepted)" >
| < BAD : "(bad destination mailbox address)" >
| < RELAY : "relay to:" >
| < TEMP_REJECTED : "temporarily rejected, dsn:" >
| < STATUS : "status=" >
| < DELIVERED : "delivered, dsn:" >
| < CONNECT : "connect from:" >
} 

<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC,VALIDA> TOKEN : {
  < LETRA : ["A"-"Z","a"-"z"] >
| < PUNTO : "." > 
| < DOS_PUNTOS : ":" >
| < IGUAL : "=" >
| < COMA : "," >
}

/* Producci√≥n principal */
void Start() : {}
{
  {eg.registrarFichero();}
  (Traza() <EOL>)* (<EOF>)?
}

/* Una Traza. */
// Se pone (<NO_FECHA>)? debido a que si hay una traza mal formada al principio del elemento, por ejemplo 2020-19-2 , el tokenmanager detecta que es un no es una fecha y genera un TokenManagerException. Esto hace que termine la ejecuccion del fichero. Para controlar ese error, colocamos esa sentencia y en caso de que se cumpla genera un ParseException, excepcion que si podemos controlar.
void Traza() : {}
{
  { eg.registrarTraza(); }
  try{
    (<NO_FECHA>)? 
    Fecha() Hora() TipoTraza() 
  } catch (Exception e) {
    skipto(EOL,e);
	} 
}

/* Un tipo de traza. */
void TipoTraza() : {}
{
  Msa() Numero() Identificador() TrazaMSA() 
| SmptIn() Numero() Identificador() TrazaIN()
| SmptOut() Numero() Identificador() TrazaOUT()    
| Sec() Numero() Identificador() TrazaSEC()  
| IdServidor() Numero() Identificador() TrazaValida() 
}

/* Rama MSA */

void TrazaMSA() : {String r;}
{ 
  r=MessageFrom() { Registar("msgIn",t,n,f); eu.registrarMensaje(r); } 
| ErrorMessage() 
| TrazaMSAValida() 
} 

String MessageFrom() : {}
{ 
  <FROM> tkn=<MAIL> {
    StringTokenizer st = new StringTokenizer(tkn.image.substring(1),"@");
    skipto(EOL,null); 
    return st.nextToken();
  }
} 

void ErrorMessage() : {}
{
  Status() | TemporarilyRejected() | PermanentlyRejected()
}

void Status() : {}
{
  <STATUS>
  (<LETRA> | <PUNTO> | <COMA> | <DOS_PUNTOS> | <IGUAL> | <NUMERO>)+ (Overload() | Accepted() | Bad())
}

void TemporarilyRejected():{}
{
  <TEMP_REJECTED>
  (<LETRA> | <PUNTO> | <COMA> | <DOS_PUNTOS> | <IGUAL> | <NUMERO>)+ Overload()
}

void Overload() : {} 
{
   <OVERLOAD> 
   { Registar("code 4.3.2",t, n, f); }
}

void Accepted() : {}
{
  <ACCEPTED>
}

void Bad() : {}
{
  <BAD>
  { Registar("code 5.1.1",t, n, f); }
}

void PermanentlyRejected() : {}
{
  <PERMA_REJECTED>
  (<LETRA> | <PUNTO> | <COMA> | <DOS_PUNTOS> | <IGUAL> | <NUMERO>)+ Bad()
}

void TrazaMSAValida() : {} 
{
  Relayto() | Delivered() | Connect() 
}

void Relayto() : {}
{
  <RELAY>
  { skipto(EOL,null); }
}

void Delivered() : {}
{
  <DELIVERED>
  { skipto(EOL,null); }
}

void Connect() : {}
{
  <CONNECT>
  { skipto(EOL,null); }
}

/* Rama SMTP-IN */

void TrazaIN() : {}
{ 
  MessageFrom()  { Registar("msgIn",t,n,f); }
| ErrorMessage()
| TrazaINValida()
}

void TrazaINValida() : {}
{
  BouncedFrom() | Relayto() | Delivered() | Connect() 
}

void BouncedFrom() : {}
{
  <BOUNCED> 
  { skipto(EOL,null); }
}

/* Rama SMTP-OUT */

void TrazaOUT() :{}
{ 
  ( Relayto() | ErrorMessage() | TrazaOUTValida() )
  { Registar("msgOut",t,n,f); } 
} 

void TrazaOUTValida() : {}
{
  MessageFrom() | Connect() | Delivered() 
}

/* Rama SEC */

void TrazaSEC() : {}
{ 
  SecBlocked() | SecPassed() | ErrorMessage() | TrazaSECValida()
} 

void SecBlocked() : {}
{
  <SEC_BLOCKED>
  (Infected() | Spam())
}

void SecPassed() : {}
{
  <SEC_PASSED>
  (Infected() | Spam())
}

void Infected() : {}
{
  <INFECTED> { 
    skipto(EOL,null);
    Registar("msgINFECTED",t, n, f); 
  }
}

void Spam() : {}
{
  (<LETRA> | <DOS_PUNTOS> | <GUION>)+ (<SPAM>{
    Registar("msgSPAM",t, n, f); } 
  |<HAM>)
}

void TrazaSECValida() : {}
{
  MessageFrom() | Connect() | Relayto() | Delivered() 
}

/* Rama VALIDA */

void TrazaValida() : {}
{
  ( <LETRA> | <NUMERO> | <GUION_BAJO> | <PUNTO> | <GUION> | <DOS_PUNTOS> | <MENOR_QUE> | <MAYOR_QUE> | <IGUAL> | <ABRE_PARENTESIS> | <CIERRA_PARENTESIS> | <COMA> | <ARROBA>)*
  {eg.registrarServidor(t,n);}
}

/* Otras producciones */

void Fecha() : {}  
{ 
  tkn=<FECHA> 
  { this.f = tkn.image; } 
}

void Hora() : {}
{ 
  <HORA> 
}

void Numero() : {}
{ 
  tkn=<NUMERO>
  { this.n = tkn.image; } 
}
 
void Identificador() : {}
{ 
  <IDENTIFICADOR_TRAZA> 
} 

void Msa() : {}
{
  tkn=<MSA>
  { this.t = tkn.image; }
}

void SmptIn() : {}
{
  tkn=<SMTP_IN>
  { this.t = tkn.image; }
}

void SmptOut() : {}
{
  tkn=<SMTP_OUT>
  { this.t = tkn.image; }
}

void Sec() : {}
{
  tkn=<SEC>
  { this.t = tkn.image; }
}

void IdServidor() : {}
{
  tkn=<ID_SERVIDOR>
  { this.t = tkn.image; }
}

<*> TOKEN : { <UNEXPECTED: ~[] > } // para que no salte un TokenManagerException
