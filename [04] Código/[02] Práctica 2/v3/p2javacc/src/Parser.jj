options
{
  STATIC = false; // para que pueda haber concurrencia (permite entradas de manera dinamica) 
  // DEBUG_PARSER = true; 
  // DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Parser)

package piat.javacc;
import java.io.File; 
import java.util.StringTokenizer;

@SuppressWarnings("unused") // quitar warnings en Parser.java
public class Parser {
  private EstUsuario eu ;
  private EstGenerales eg ;
  private EstAgregadasTipoFecha ea ;
  private File fichero;

  private String f,t,n;
  private Token tkn;

  public Parser(ParserTokenManager parser, EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea,File fichero){
    this(parser); 
    this.eu = eu;
    this.eg = eg;
    this.ea = ea;
    this.fichero = fichero;
  }

  void skipto(int kind, Exception e){
    if(e!=null){
      // System.out.println(fichero+"ERROR EN PARSER.Traza mal formada detectada..."+e.getMessage());
      eg.registrarError();
    } 
    while(getToken(1).kind != kind) // https://javacc.github.io/javacc/documentation/api.html#returning-tokens
      getNextToken(); 
	}

  private void Registar(String estadistico, String tipoServidor, String numeroServidor,String fecha){
    eg.registrarServidor(tipoServidor,numeroServidor);
		ea.registrarTraza(tipoServidor,fecha,estadistico);
  }

}

PARSER_END(Parser)

<*>
SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN : 
{
  < FECHA : (["0"-"9"]){4}"-"(["0"-"9"]){2}"-"(["0"-"9"]){2} >  
| < HORA : (["0"-"9"]){2}":"(["0"-"9"]){2}":"(["0"-"9"]){2} > : SERVER
| < NO_FECHA : ~["\n"] > //cualquier cosa que no sea una fecha
}

<*>
TOKEN:
{
  < EOL : "\n" > : DEFAULT
}

/** Los siguientes tokens tienen que ser especificados en todos los estados lexicos (*) ya que en la parte sintactica si ponemos un token a pelo (por ejemplo: "message from"), el parser lo detecta como un token definido el estado léxico DEFAULT, no un token definido en todo estado lexico. Es por ello que el no-terminal CualquierCosa se ponen los tokens definidos a continuación */
/** El estado lexico server se ha definido principalmente por un motivo, y es debido a que en mucho ficheros de log se encuentra tipos de servidor (bounced from: <MAILER-DAEMON@smtp-in2.etsist.upm.es> ) por lo que es necesario definir un estado lexico en el que unicamente queramos detectar el tipo de servidor al que pertenece la traza. */
<SERVER>
TOKEN:
{
  < MSA : "msa" > : LEX_MSA
| < SMTP_IN : "smtp-in" > : LEX_IN 
| < SMTP_OUT : "smtp-out" > : LEX_OUT
| < SEC : ("security-in"|"security-out") > : LEX_SEC
| < ID_SERVIDOR :  ((<LETRA>)+("-")?(<LETRA>)+) > : VALIDA
}

<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC,NUM,VALIDA>
TOKEN:
{
  < NUMERO : ["0"-"9"] > 
}

<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC,VALIDA>
TOKEN:
{
  < IDENTIFICADOR_TRAZA : "["(["A"-"Z","0"-"9"])+"]:" >    // el id de traza tiene que estar aqui definido porque algunos servidores utilizan estados lexicos propios
}

<LEX_IN>
TOKEN:
{
  < BOUNCED : "bounced from:">  // este token se define ya que en los smtp-in hay este token seguido de un remitente y correo, por lo que cuando lo detectemos debemos salir de ese estado lexico y ir al por defecto
| < PERMA_REJECTED : "permanently rejected, dsn:" >
}

<LEX_SEC>
TOKEN:
{
  < INFECTED : "security-antivirus: INFECTED" >
// | < CLEAN : "security-antivirus: CLEAN" >
| < SPAM : "security-antispam: SPAM" >
| < SEC_PASSED : "SEC-PASSED:" >
| < SEC_BLOCKED : "SEC-BLOCKED:" >
| < HAM : "security-antispam: HAM" >
}

<VALIDA>
TOKEN:
{
  < MENOR_QUE : "<" >
| < MAYOR_QUE : ">" >
| < ARROBA : "@" >
| < ABRE_PARENTESIS : "(" >
| < CIERRA_PARENTESIS : ")" >
| < GUION_BAJO : "_" >
}

<VALIDA,LEX_SEC>
TOKEN:
{
  < GUION : "-" >
}

// <GEN,ENV>
// TOKEN:
// {
//  < REMIT : "<"(["A"-"Z","a"-"z","0"-"9","_",".","-"])+ >
// | < DOM : "@"(["A"-"Z","a"-"z","0"-"9","_"])+ ("."(["A"-"Z","a"-"z","0"-"9","_"])+)+">" >
// }



<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC>
TOKEN:
{
  < MAIL : "<"(["A"-"Z","a"-"z","0"-"9","_",".","-"])+ "@"(["A"-"Z","a"-"z","0"-"9","_","-"])+ ("."(["A"-"Z","a"-"z","0"-"9","_"])+)+">" >
| < FROM :  "message from:" >
| < OVERLOAD : "(overload)" >
| < ACCEPTED : "(accepted)" >
| < BAD : "(bad destination mailbox address)" >
}

<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC>
TOKEN:
{
  < RELAY : "relay to:" >
| < TEMP_REJECTED : "temporarily rejected, dsn:" >
| < STATUS : "status=" >
| < DELIVERED : "delivered, dsn:" >
| < CONNECT : "connect from:" >
} 

<LEX_MSA,LEX_IN,LEX_OUT,LEX_SEC,VALIDA>
TOKEN:
{
  < LETRA : ["A"-"Z","a"-"z"] >
| < PUNTO : "." > 
| < DOS_PUNTOS : ":" >
| < IGUAL : "=" >
| < COMA : "," >
}

/** Producción principal. */
// Se pone (<EOL>)? ya que en algunos no-terminales una vez se ha detectado lo que interesa, consume todos los tokens de esa traza hasta llegar al final de línea, consumiendo tambien ese token. Es por eso que en esos casos puede no estar presente el <EOL>
void Start() : {}
{
  {eg.registrarFichero();}
  (Traza() <EOL>)* (<EOF>)?
}

/** Una Traza. */
// Se pone (<NO_FECHA>{skipto(EOL,new Exception());})?  debido a que si hay una traza mal formada al principio del elemento, por ejemplo 2020-19-2 , el tokenmanager detecta que es un numero y genera un TokenManagerException. Esto hace que termine la ejecuccion del fichero. Para controlar ese error, colocamos esa sentencia y en caso de que se cumple consumimos todos los tokens hasta EOL
void Traza() : {}
{
  { eg.registrarTraza(); }
  try{
    (<NO_FECHA>)? 
    Fecha() Hora() TipoTraza() 
  } catch (Exception e) {
    skipto(EOL,e);
	} 
}

/** Un tipo de traza. */
/** El LOOKAHEAD sirve para poder comprobar todas los tipos de trazas que se quieren analizar y ver de todas ellas cual es la que encaja. Concretamente, el LOOKAHEAD tiene como funcion mirar un numero n de tokens hacia delante, para poder determinar que no-terminal es el correcto.*/
void TipoTraza() : {}
{
  Msa() Numero() Identificador() TrazaMSA() 
| SmptIn() Numero() Identificador() TrazaIN()
| SmptOut() Numero() Identificador() TrazaOUT()    
| Sec() Numero() Identificador() TrazaSEC()  
| IdServidor() Numero() Identificador() TrazaValida() 
}

/* Primer nivel del arbol */
void TrazaMSA() : {String r;}
{ 
  r=MessageFrom() { Registar("msgIn",t,n,f); eu.registrarMensaje(r); } 
| ErrorMessage() 
| TrazaMSAValida() 
} 

void TrazaIN() : {}
{ 
  MessageFrom()  { Registar("msgIn",t,n,f); }
| ErrorMessage()
| TrazaINValida()
}

void TrazaOUT() :{}
{ 
  ( Relayto() | ErrorMessage() | TrazaOUTValida() )
  { Registar("msgOut",t,n,f); } 
} 

void TrazaSEC() : {}
{ 
  SecBlocked() | SecPassed() | ErrorMessage() | TrazaSECValida()
} 

/** Rama de MSA **/
String MessageFrom() : {}
{ 
  <FROM> tkn=<MAIL> {
    StringTokenizer st = new StringTokenizer(tkn.image.substring(1),"@");
    skipto(EOL,null); 
    return st.nextToken();
  }
} 

void TrazaMSAValida() : {} 
{
  Relayto() | Delivered() | Connect() 
}

void Delivered() : {}
{
  <DELIVERED>
  { skipto(EOL,null); }
}

void Connect() : {}
{
  <CONNECT>
  { skipto(EOL,null); }
}

void Relayto() : {}
{
  <RELAY>
  { skipto(EOL,null); }
}

void ErrorMessage() : {}
{
  Status() | TemporarilyRejected() | PermanentlyRejected()
}

void TemporarilyRejected():{}
{
  <TEMP_REJECTED>
  (<LETRA> | <PUNTO> | <COMA> | <DOS_PUNTOS> | <IGUAL> | <NUMERO>)+ Overload()
}

void Status() : {}
{
  <STATUS>
  (<LETRA> | <PUNTO> | <COMA> | <DOS_PUNTOS> | <IGUAL> | <NUMERO>)+ (Overload() | Accepted() | Bad())
}

void Overload() : {} 
{
   <OVERLOAD> 
   { Registar("code 4.3.2",t, n, f); }
}

void Accepted() : {}
{
  <ACCEPTED>
}

void Bad() : {}
{
  <BAD>
  { Registar("code 5.1.1",t, n, f); }
}

/**********************/
/** Rama de SMTP_IN **/

void TrazaINValida() : {}
{
  BouncedFrom() | Relayto() | Delivered() | Connect() 
}

void BouncedFrom() : {}
{
  <BOUNCED> 
  { skipto(EOL,null); }
}

void PermanentlyRejected() : {}
{
  <PERMA_REJECTED>
  (<LETRA> | <PUNTO> | <COMA> | <DOS_PUNTOS> | <IGUAL> | <NUMERO>)+ Bad()
}

/**********************/
/** Rama de SMTP_OUT **/

void TrazaOUTValida() : {}
{
  MessageFrom() | Connect() | Delivered() 
}

/**********************/
/** Rama de SEC **/

void SecBlocked() : {}
{
  <SEC_BLOCKED>
  (Infected() | Spam())
}

void SecPassed() : {}
{
  <SEC_PASSED>
  (Infected() | Spam())
}

void Infected() : {}
{
  <INFECTED> { 
    skipto(EOL,null);
    Registar("msgINFECTED",t, n, f); 
  }
}

void Spam() : {}
{
  (<LETRA> | <DOS_PUNTOS> | <GUION>)+ (<SPAM>{
    Registar("msgSPAM",t, n, f); } 
  |<HAM>)
}

void TrazaSECValida() : {}
{
  MessageFrom() | Connect() | Relayto() | Delivered() 
}
/**********************/

/* Otras producciones */
void Fecha() : {}  
{ 
  tkn=<FECHA> 
  { this.f = tkn.image; } 
}

void Hora() : {}
{ 
  <HORA> 
}

void Numero() : {}
{ 
  tkn=<NUMERO>
  { this.n = tkn.image; } 
}
 
void Identificador() : {}
{ 
  <IDENTIFICADOR_TRAZA> 
} 

void Msa() : {}
{
  tkn=<MSA>
  { this.t = tkn.image; }
}

void SmptIn() : {}
{
  tkn=<SMTP_IN>
  { this.t = tkn.image; }
}

void SmptOut() : {}
{
  tkn=<SMTP_OUT>
  { this.t = tkn.image; }
}

void Sec() : {}
{
  tkn=<SEC>
  { this.t = tkn.image; }
}

void IdServidor() : {}
{
  tkn=<ID_SERVIDOR>
  { this.t = tkn.image; }
}

void TrazaValida() : {}
{
  ( <LETRA> | <NUMERO> | <GUION_BAJO> | <PUNTO> | <GUION> | <DOS_PUNTOS> | <MENOR_QUE> | <MAYOR_QUE> | <IGUAL> | <ABRE_PARENTESIS> | <CIERRA_PARENTESIS> | <COMA> | <ARROBA>)*
  {eg.registrarServidor(t,n);}
}

<*> TOKEN : { <UNEXPECTED: ~[] > } // para que no salte un tokenexception. en caso de que haya tokens no definidos.
