options
{
  STATIC = false; // para que pueda haber concurrencia (permite entradas de manera dinamica) 
  // DEBUG_PARSER = true;
  // DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Parser)

package piat.javacc;
import java.util.Map;
import java.util.HashMap;

public class Parser {
  final boolean VERBOSE = false;
  // private EstUsuario eu = new EstUsuario();
  // private EstGenerales eg = new EstGenerales();



  // Nombres para los estadísticos agregados por tipo de servidor y día
	private static final Map<String,String> nombreEst = new HashMap<String,String>();
	static
	{
		nombreEst.put ( "message from", "msgIn" );
		nombreEst.put ( "relay to", "msgOut" );
		nombreEst.put ( "INFECTED", "msgINFECTED" );
		nombreEst.put ( "SPAM", "msgSPAM" );
		nombreEst.put ( "overload", "code 4.3.2" );
		nombreEst.put ( "bad", "code 5.1.1" );
	}
  
  void skipto(int kind, Exception e){
      if(e!=null){
        System.out.println("\u001B[31m"+"Traza mal formada detectada..."+"\u001B[0m");
      }
		Token t; 
    	do {
        	t = getNextToken();
  		} while (t.kind != kind);
	}
}
PARSER_END(Parser)

<*>
SKIP :
{
  " "
| "\t"
| "\r"
}

/** Los siguientes tokens tienen que ser especificados en todos los estados lexicos (*) ya que en la parte sintactica si ponemos un token a pelo (por ejemplo: "message from"), el parser lo detecta como un token definido el estado léxico DEFAULT, no un token definido en todo estado lexico. Es por ello que el no-terminal CualquierCosa se ponen los tokens definidos a continuación */
<*>
TOKEN:
{
  < NUMERO : (["0"-"9"])+ > 
| < LETRA : ["A"-"Z","a"-"z"] >
| < IDENTIFICADOR_TRAZA : "["(["A"-"Z","0"-"9"])+"]:" > // el id de traza tiene que estar aqui definido porque algunos servidores utilizan estados lexicos propios
| < PUNTO : "." > 
| < DOS_PUNTOS : ":" >
| < GUION : "-" >
| < GUION_BAJO : "_" >
| < ARROBA : "@" >
| < IGUAL : "=" >
| < ABRE_PARENTESIS : "(" >
| < CIERRA_PARENTESIS : ")" >
| < COMA : "," >
| < MENOR_QUE : "<" >
| < MAYOR_QUE : ">" >
| < EOL : "\n" > : DEFAULT 
}

TOKEN : 
{
  < FECHA : (["0"-"9"]){4}"-"(["0"-"9"]){2}"-"(["0"-"9"]){2} >  
| < HORA : (["0"-"9"]){2}":"(["0"-"9"]){2}":"(["0"-"9"]){2} > : SERVER
}

/** El estado lexico server se ha definido principalmente por un motivo, y es debido a que en mucho ficheros de log se encuentra tipos de servidor (bounced from: <MAILER-DAEMON@smtp-in2.etsist.upm.es> ) por lo que es necesario definir un estado lexico en el que unicamente queramos detectar el tipo de servidor al que pertenece la traza. */
<SERVER>
TOKEN:
{
  < MSA : "msa" > : GEN
| < SMTP_IN : "smtp-in" > : DEFAULT //: GEN
| < SMTP_OUT : "smtp-out" > : OUT
| < SEC : ("security-in"|"security-out") > : DEFAULT
}

/** Este estado lexico se define ya que hace falta definir los token que queramos que se identifiquen en las trazas security-in/out */
<SECURITY>
TOKEN:
{
  < INFECTED : "INFECTED" > : DEFAULT
| < SEC_PASSED : "SEC-PASSED:" > : PASS
| < SECURITY_ANTIVIRUS : "security-antivirus:" >
}

<GEN>
TOKEN:
{
  < REMIT : "<"(["A"-"Z","a"-"z","0"-"9","_",".","-"])+ >
| < DOM : "@"(["A"-"Z","a"-"z","0"-"9","_"])+ ("."(["A"-"Z","a"-"z","0"-"9","_"])+)+">" >
| < FROM :  "message from:" >
}

<OUT>
TOKEN:
{
  <RELAY_TO : "relay to:" > 
}

/** Este estado se define ya que hay tanto para los mensajes SEC-BLOCKED (infectados) como SEC-PASSED (spam) existe el "token" security-antivirus. En el caso de mensajes infectados es imprescindible que aparezca "security-antivirus", mientras que los de SPAM no. Es por ello por lo que se ha creado un estado lexico para que "obvie" ese token y no haya conflictos a la hora de que el tokenmanager detecte el token. */
<PASS>
TOKEN:
{
  <SECURITY_ANTISPAM : "security-antispam:" >
| <SPAM : "SPAM" >
}

/** Producción principal. */
// Se pone (<EOL>)? ya que en algunos no-terminales una vez se ha detectado lo que interesa, consume todos los tokens de esa traza hasta llegar al final de línea, consumiendo tambien ese token. Es por eso que en esos casos puede no estar presente el <EOL>
void Start(EstUsuario eu, EstGenerales eg) : {
  // this.eu = eu;
  // this.eg = eg;
}
{
  {eg.registrarFichero();}

  (Traza(eu,eg) (<EOL>)?)*
  <EOF>
}

/** Una Traza. */
void Traza(EstUsuario eu, EstGenerales eg) : {}
{
  // try {
    {eg.registrarTraza();}
    Fecha() Hora() TipoTraza(eu,eg) 
	// } catch (Exception e) {
    // {eg.registrarError();}
    // skipto(EOL,e);
	// } 
}

/** Un tipo de traza. */
/** El LOOKAHEAD sirve para poder comprobar todas los tipos de trazas que se quieren analizar y ver de todas ellas cual es la que encaja. Concretamente, el LOOKAHEAD tiene como funcion mirar un numero n de tokens hacia delante, para poder determinar que no-terminal es el correcto.*/
void TipoTraza(EstUsuario eu, EstGenerales eg) : {}
{
  LOOKAHEAD(TrazaGEN())   TrazaGEN(eu,eg) 
| LOOKAHEAD(TrazaIN())    TrazaIN(eu,eg)
| LOOKAHEAD(TrazaOUT())   TrazaOUT(eu,eg)    // [HECHO]
| LOOKAHEAD(TrazaINF())   TrazaINF(eu,eg)    // [HECHO]
| LOOKAHEAD(TrazaSPAM())  TrazaSPAM(eu,eg)   // [HECHO]
| LOOKAHEAD(TrazaOVER())  TrazaOVER(eu,eg)   // [HECHO]
| LOOKAHEAD(TrazaBAD())   TrazaBAD(eu,eg)    // [HECHO]
| LOOKAHEAD(TrazaValida())TrazaValida(eu,eg) // [HECHO]
}

void TrazaGEN(EstUsuario eu, EstGenerales eg) : { Token t; String u,n; }
{ t=<MSA> n=Numero() Identificador() u=Intento(t) {
    eg.registrarServidor(t.image,n);
    eu.registrarMensaje(u);} } 

void TrazaIN(EstUsuario eu, EstGenerales eg) : { Token t; String n; }
{ 
  t=<SMTP_IN> n=Numero() Identificador() 
  Intento(t)
  {eg.registrarServidor(t.image,n);}
  // MessageFrom() MessageTo() MessageId() Size() 
}

void TrazaOUT(EstUsuario eu, EstGenerales eg) : { Token t; String n;}
{ t=<SMTP_OUT> n=Numero() Identificador() RelayTo(t) {eg.registrarServidor(t.image,n);} } 

void TrazaSPAM(EstUsuario eu, EstGenerales eg) : { Token t; String n;}
{ t=<SEC> n=Numero() Identificador() SpamNoBloq(t) {eg.registrarServidor(t.image,n);} } 

void TrazaINF(EstUsuario eu, EstGenerales eg) : { Token t; String n;}
{ t=<SEC> n=Numero() Identificador() Infectado(t) {eg.registrarServidor(t.image,n);}} 

void TrazaOVER(EstUsuario eu, EstGenerales eg) : { Token t; String n;}
{ t=TipoServidor() n=Numero() Identificador() Sobrecarga(t) {eg.registrarServidor(t.image,n);}} 

void TrazaBAD(EstUsuario eu, EstGenerales eg) : { Token t;String n;}
{ t=TipoServidor() n=Numero() Identificador() Nodest(t) {eg.registrarServidor(t.image,n);}} 

void TrazaValida(EstUsuario eu, EstGenerales eg) : {Token t ;String n;}
{ t=TipoServidor() n=Numero() Identificador() CualquierCosa() {eg.registrarServidor(t.image,n);}} 

Token TipoServidor() : { Token t; }
{ ( t=<MSA> | t=<SMTP_IN> | t=<SMTP_OUT> | t=<SEC> ) {return t;} }

void Fecha() : {}
{ <FECHA> }

void Hora() : {}
{ <HORA> }

String Numero() : {Token t;}
{ t=<NUMERO>{return t.image;} }

void Identificador() : {}
{ <IDENTIFICADOR_TRAZA> } 

String Intento(Token t) : { Token u,v; }
{
  <FROM> u = <REMIT> v = <DOM> {
    if(VERBOSE) System.out.println("\u001B[33m"+"["+t.image+"] message from: "+u.image.substring(1)+"@"+v.image.substring(1, v.image.length() - 1)+"\u001B[0m");
    skipto(EOL,null);
    return u.image.substring(1);
  }
}

void RelayTo(Token t) : { String s; }
{
  <RELAY_TO> s=Relay(){
    if(VERBOSE)System.out.println("\u001B[33m"+"["+t.image+"] relay to: "+s+"\u001B[0m");
    skipto(EOL,null);
  }
}

void SpamNoBloq(Token t) : { Token u; }
{
  <SEC_PASSED> CualquierCosa() <SECURITY_ANTISPAM> u=<SPAM> 
  {
    if(VERBOSE)System.out.println("\033[0;36m"+"["+t.image+"] "+u.image+"\u001B[0m");
  }
}

void Infectado(Token t) : { Token u; }
{
  CualquierCosa() <SECURITY_ANTIVIRUS> u=<INFECTED> 
  {
    if(VERBOSE)System.out.println("\u001B[31m"+"["+t.image+"] "+u.image+"\u001B[0m");
    skipto(EOL,null);
  }
}

void Sobrecarga(Token t) : {} 
{
  CualquierCosa() "overload)"
  // CualquierCosa() <OVERLOAD>
  {
    if(VERBOSE)System.out.println("\033[0;36m"+"["+t.image+"] (overload)"+"\u001B[0m");
    // skipto(EOL,null);
  }
}

void Nodest(Token t) : {}
{
  CualquierCosa() "(bad" "destination mailbox address)"
  // CualquierCosa() <BAD> 
  {
    if(VERBOSE)System.out.println("\033[0;35m"+"["+t.image+"] (bad destination mailbox address)"+"\u001B[0m");
    // skipto(EOL,null);
  }
}

/** Se define el no-terminal CualquierCosa y no un token que recoga cualquier cosa (~[]) , debido a que este ultimo no permitiría reconocer ningun otro token que quisiesemos, aunque estos tuviesen prioridad. Es mas conveniente definir un no-terminal con los cualquier token que puede haber hasta encontrar el token que queramos reconocer. */
void CualquierCosa() : {}
{
  ( <LETRA> | <NUMERO> | <GUION_BAJO> | <PUNTO> | <GUION> | <DOS_PUNTOS> | <MENOR_QUE> | <MAYOR_QUE> | <IGUAL> | <ABRE_PARENTESIS> | <CIERRA_PARENTESIS> | <COMA> | <ARROBA> )*
}

String Relay() : { Token t; String s = ""; }
{
  ( t=<LETRA>{s += t.image;} | t=<NUMERO>{s += t.image;} | t="_"{s += t.image;} | t="."{s += t.image;} | t="-"{s += t.image;} )*
  {return s;}
}

/** METODOS NO UTILIZADOS */

// void MessageFrom() : {}
// { "message from:" CorreoElectronico() } 

// void MessageTo() : {}
// {  "to:" CorreoElectronico() }

// void MessageId() : {}
// {  "message-id:" CorreoElectronico() }

// void Size() : {}
// { "size:"Numero() }

// void CorreoElectronico() : 
// {
//   String remitente = "";
//   String dominio = "";
//   Token t;
// }
// {
//   "<"
//   ( t = <LETRA>{remitente += t.image;} | t = <NUMERO>{remitente += t.image;} | t ="_" {remitente += t.image;}| t = "." {remitente += t.image;}| t ="-"{remitente += t.image;} )*
//   t="@"
//   ( t = <LETRA>{dominio += t.image;} | t = <NUMERO>{dominio += t.image;} | t ="_" {dominio += t.image;}| t = "." {dominio += t.image;}| t ="-"{dominio += t.image;} )*
//   ">"{
//     // System.out.println(remitente+"@"+dominio);
//   }
// }


<*> TOKEN : { <UNEXPECTED: ~[] > }