options
{
  STATIC = false; // para que pueda haber concurrencia (permite entradas de manera dinamica) 
  // DEBUG_PARSER = true;
  // DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Parser)
package piat.javacc;

@SuppressWarnings("unused") // quitar warnings en Parser.java
public class Parser {
  final boolean VERBOSE = true;
  private EstUsuario eu ;
  private EstGenerales eg ;
  private EstAgregadasTipoFecha ea ;
  // private static int linea = 0;

  public Parser(ParserTokenManager p, EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea){
    this(p);
    this.eu = eu;
    this.eg = eg;
    this.ea = ea;
  }
  void skipto(EstGenerales eg,int kind, Exception e){
      if(e!=null){
        System.out.println("Traza mal formada detectada..."+e.getMessage());
        eg.registrarError();
      }
		Token t;  
    	do {  
        	t = getNextToken();
  		} while (t.kind != kind);
	}

  private void Registar(EstGenerales eg, EstAgregadasTipoFecha ea,String estadistico, Token tipoServidor, String numeroServidor,String fecha){
    eg.registrarServidor(tipoServidor.image,numeroServidor);
		ea.registrarTraza ( tipoServidor.image, fecha, estadistico );
  }

}
PARSER_END(Parser)

<*>
SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN : 
{
  < FECHA : (["0"-"9"]){4}"-"(["0"-"9"]){2}"-"(["0"-"9"]){2} >  
| < HORA : (["0"-"9"]){2}":"(["0"-"9"]){2}":"(["0"-"9"]){2} > : SERVER
| < ANY : ~["\n"] > //cualquier cossa que no sea una fecha
}

/** Los siguientes tokens tienen que ser especificados en todos los estados lexicos (*) ya que en la parte sintactica si ponemos un token a pelo (por ejemplo: "message from"), el parser lo detecta como un token definido el estado léxico DEFAULT, no un token definido en todo estado lexico. Es por ello que el no-terminal CualquierCosa se ponen los tokens definidos a continuación */
<*>
TOKEN:
{
  < NUMERO : (["0"-"9"])+ > 
| < LETRA : ["A"-"Z","a"-"z"] >
| < IDENTIFICADOR_TRAZA : "["(["A"-"Z","0"-"9"])+"]:" > // el id de traza tiene que estar aqui definido porque algunos servidores utilizan estados lexicos propios
| < PUNTO : "." > 
| < DOS_PUNTOS : ":" >
| < GUION : "-" >
| < GUION_BAJO : "_" >
| < ARROBA : "@" >
| < IGUAL : "=" >
| < ABRE_PARENTESIS : "(" >
| < CIERRA_PARENTESIS : ")" >
| < COMA : "," >
| < MENOR_QUE : "<" >
| < MAYOR_QUE : ">" >
| < BOUNCED : "bounced from:"> : DEFAULT // este token se define ya que en los smtp-in hay este token seguido de un remitente y correo, por lo que cuando lo detectemos debemos salir de ese estado lexico y ir al por defecto
| < OVERLOAD : "(overload)" > // este token tiene que estar aqui definido ya que puede aparecer en cualquier tipo de servidor
| < BAD : "(bad destination mailbox address)" > // este token tiene que estar aqui definido ya que puede aparecer en cualquier tipo de servidor
| < EOL : "\n" > : DEFAULT // se encuentre en el estado lexico que se encuentre, cuando encuentre un EOL pasa a default (siguiente linea)
}

/** El estado lexico server se ha definido principalmente por un motivo, y es debido a que en mucho ficheros de log se encuentra tipos de servidor (bounced from: <MAILER-DAEMON@smtp-in2.etsist.upm.es> ) por lo que es necesario definir un estado lexico en el que unicamente queramos detectar el tipo de servidor al que pertenece la traza. */
<SERVER>
TOKEN:
{
  < MSA : "msa" > : GEN
| < SMTP_IN : "smtp-in" > : GEN 
| < SMTP_OUT : "smtp-out" > : OUT
| < SEC : ("security-in"|"security-out") > : SECURITY
| < USER_MAILBOX : "user-mailbox" > // salimos de este estado lexico ya que no queremos detectar ningun token en este tipo de traza
}

/** Este estado lexico se define ya que hace falta definir los token que queramos que se identifiquen en las trazas security-in/out */
<SECURITY>
TOKEN:
{
  < INFECTED : "security-antivirus: INFECTED" > : DEFAULT
| < SEC_PASSED : "SEC-PASSED:" > : PASS
}

<GEN>
TOKEN:
{
  < REMIT : "<"(["A"-"Z","a"-"z","0"-"9","_",".","-"])+ >
| < DOM : "@"(["A"-"Z","a"-"z","0"-"9","_"])+ ("."(["A"-"Z","a"-"z","0"-"9","_"])+)+">" >
| < FROM :  "message from:" >
}

<OUT>
TOKEN:
{
  <RELAY_TO : "relay to:" > 
}

/** Este estado se define ya que hay tanto para los mensajes SEC-BLOCKED (infectados) como SEC-PASSED (spam) existe el "token" security-antivirus. En el caso de mensajes infectados es imprescindible que aparezca "security-antivirus", mientras que los de SPAM no. Es por ello por lo que se ha creado un estado lexico para que "obvie" ese token y no haya conflictos a la hora de que el tokenmanager detecte el token. */
<PASS>
TOKEN:
{
  <SPAM : "security-antispam: SPAM" >
}

/** Producción principal. */
// Se pone (<EOL>)? ya que en algunos no-terminales una vez se ha detectado lo que interesa, consume todos los tokens de esa traza hasta llegar al final de línea, consumiendo tambien ese token. Es por eso que en esos casos puede no estar presente el <EOL>
void Start() : {}
{
  {eg.registrarFichero();}
  try{
    (Traza(eu,eg,ea) (<EOL>)?)* <EOF>
  } catch (Exception e) {
    // e.printStackTrace();
    skipto(eg,EOL,e);
	} 
}

/** Una Traza. */
// Se pone (<NUMERO>)? debido a que si hay una traza mal formada al principio del elemento, por ejemplo 2020-19-2 , el tokenmanager detecta que es un numero y genera un TokenManagerException. Esto hace que termine la ejecuccion del fichero. Para controlar ese error, colocamos esa sentencia y en caso de que se cumple consumimos todos los tokens hasta EOL
void Traza(EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ String f; }
{
  { eg.registrarTraza(); }
  try{
  (<ANY>{skipto(eg,EOL,new Exception());})?
  f=Fecha() Hora() TipoTraza(f, eu, eg,  ea) 
  } catch (Exception e) {
    // e.printStackTrace();
    skipto(eg,EOL,e);
	} 
}

/** Un tipo de traza. */
/** El LOOKAHEAD sirve para poder comprobar todas los tipos de trazas que se quieren analizar y ver de todas ellas cual es la que encaja. Concretamente, el LOOKAHEAD tiene como funcion mirar un numero n de tokens hacia delante, para poder determinar que no-terminal es el correcto.*/
void TipoTraza(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : {}
{
  LOOKAHEAD(TrazaGEN())     TrazaGEN(f,eu,eg,ea) 
| LOOKAHEAD(TrazaIN())      TrazaIN(f,eu,eg,ea)
| LOOKAHEAD(TrazaOUT())     TrazaOUT(f,eu,eg,ea)    
| LOOKAHEAD(TrazaINF())     TrazaINF(f,eu,eg,ea)    
| LOOKAHEAD(TrazaSPAM())    TrazaSPAM(f,eu,eg,ea)    
| LOOKAHEAD(TrazaOVER())    TrazaOVER(f,eu,eg,ea)   
| LOOKAHEAD(TrazaBAD())     TrazaBAD(f,eu,eg,ea)    
| LOOKAHEAD(TrazaValida())  TrazaValida(f,eu,eg,ea) 
}

void TrazaGEN(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ Token t; String u,n; }
{ 
  t=<MSA> n=Numero() Identificador() u=Intento(t,eg) 
  { Registar(eg,ea,"message from",t, n, f); eu.registrarMensaje(u); } 
} 

void TrazaIN(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ Token t; String n; }
{ 
  t=<SMTP_IN> n=Numero() Identificador()  Intento(t,eg)
  { Registar(eg,ea,"message from",t, n, f); }
}

void TrazaOUT(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) :
{ Token t; String n; }
{ 
  t=<SMTP_OUT> n=Numero() Identificador() RelayTo(t,eg) 
  { Registar(eg,ea,"msgOut",t, n, f); } 
} 

void TrazaSPAM(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ Token t; String n; }
{ 
  t=<SEC> n=Numero() Identificador() SpamNoBloq(t)
  { Registar(eg,ea,"msgSPAM",t, n, f); } 
} 

void TrazaINF(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ Token t; String n; }
{ 
  t=<SEC> n=Numero() Identificador() Infectado(t,eg) 
  { Registar(eg,ea,"msgINFECTED",t, n, f); }
} 
 
void TrazaOVER(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ Token t; String n; }
{ 
  t=TipoServidor() n=Numero() Identificador() Sobrecarga(t) 
  { Registar(eg,ea,"code 4.3.2",t, n, f); }
} 

void TrazaBAD(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ Token t;String n; }
{ 
  t=TipoServidor() n=Numero() Identificador() Nodest(t)
  { Registar(eg,ea,"code 5.1.1",t, n, f); }
} 

void TrazaValida(String f,EstUsuario eu, EstGenerales eg, EstAgregadasTipoFecha ea) : 
{ Token t ;String n; }
{ 
  t=TipoServidor() n=Numero() Identificador() (<BOUNCED>{skipto(eg,EOL,null);})? (CualquierCosa()) 
  { eg.registrarServidor(t.image,n);} } 

/** Otras producciones */ 
 Token TipoServidor() :
{ Token t; }
{ 
  ( t=<MSA> | t=<SMTP_IN> | t=<SMTP_OUT> | t=<SEC> | t=<USER_MAILBOX>)
  { return t; } 
}

String Fecha() : 
{ Token t; }  
{ 
  t=<FECHA> 
  { return t.image; } 
}

void Hora() : {}
{ 
  <HORA> 
}

String Numero() : 
{ Token t; }
{ 
  t=<NUMERO>
  { return t.image; } 
}
 
void Identificador() : {}
{ 
  <IDENTIFICADOR_TRAZA> 
} 

String Intento(Token t,EstGenerales eg) : 
{ Token u,v; }
{ 
  <FROM> u = <REMIT> v = <DOM> {
    skipto(eg,EOL,null);
    return u.image.substring(1);
  }
} 

void RelayTo(Token t,EstGenerales eg) : 
{ String s; }
{
  <RELAY_TO> s=Relay(){
    skipto(eg,EOL,null);
  }
}

void SpamNoBloq(Token t) : 
{ Token u; }
{
  <SEC_PASSED> CualquierCosa() u=<SPAM> 
}

void Infectado(Token t,EstGenerales eg) : 
{ Token u; }
{
  CualquierCosa() u=<INFECTED>
  {
    skipto(eg,EOL,null); 
  }
}

void Sobrecarga(Token t) : {} 
{
  CualquierCosa() <OVERLOAD> 
}

void Nodest(Token t) : {}
{
  CualquierCosa() <BAD>
}

/** Se define el no-terminal CualquierCosa y no un token que recoga cualquier cosa (~[]) , debido a que este ultimo no permitiría reconocer ningun otro token que quisiesemos, aunque estos tuviesen prioridad. Es mas conveniente definir un no-terminal con los cualquier token que puede haber hasta encontrar el token que queramos reconocer. */
void CualquierCosa() : {}
{
  (<SEC_PASSED>)?
  ( <LETRA> | <NUMERO> | <GUION_BAJO> | <PUNTO> | <GUION> | <DOS_PUNTOS> | <MENOR_QUE> | <MAYOR_QUE> | <IGUAL> | <ABRE_PARENTESIS> | <CIERRA_PARENTESIS> | <COMA> | <ARROBA>)*

}

String Relay() : 
{ Token t; String s = ""; }
{
  ( t=<LETRA>{ s += t.image; } | t=<NUMERO>{ s += t.image; } | t="_"{ s += t.image; } | t="."{ s += t.image; } | t="-"{ s += t.image; } )*
  { return s; }
}

/** METODOS NO UTILIZADOS */

// void MessageFrom() : {}
// { "message from:" CorreoElectronico() } 

// void MessageTo() : {}
// {  "to:" CorreoElectronico() }

// void MessageId() : {}
// {  "message-id:" CorreoElectronico() }

// void Size() : {}
// { "size:"Numero() }

// void CorreoElectronico() : 
// {
//   String remitente = "";
//   String dominio = "";
//   Token t;
// }
// {
//   "<"
//   ( t = <LETRA>{remitente += t.image;} | t = <NUMERO>{remitente += t.image;} | t ="_" {remitente += t.image;}| t = "." {remitente += t.image;}| t ="-"{remitente += t.image;} )*
//   t="@"
//   ( t = <LETRA>{dominio += t.image;} | t = <NUMERO>{dominio += t.image;} | t ="_" {dominio += t.image;}| t = "." {dominio += t.image;}| t ="-"{dominio += t.image;} )*
//   ">"{
//     // System.out.println(remitente+"@"+dominio);
//   }
// }

<*> TOKEN : { <UNEXPECTED: ~[] > } // para que no salte un tokenexception. en caso de que haya tokens no definidos.
